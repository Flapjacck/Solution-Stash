# [230. Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1827210201/)

## Notes

- Use an inorder traversal (left, node, right) because it visits BST values in ascending order.
- Perform the traversal recursively with an early exit: decrement `k` when visiting a node; when `k` reaches 0 the current node is the k-th smallest.
- Use a helper `inorder()` that accepts pointers to `k` and `ans` so it can stop early and propagate the answer.
- This allows an early return once the k-th element is found (best-case faster than visiting all nodes).

### Time Complexity: O(n)

Where n is the number of nodes in the tree:

- In the worst case (k == n or element not found early) we visit every node once: O(n).
- Early exit may stop traversal after visiting k nodes, but worst-case remains O(n).

### Space Complexity: O(h)

Where h is the height of the tree:

- Recursion stack uses O(h) space.
- No additional data structures are used (answer stored in an int).
- In worst case (skewed tree) h = n -> O(n); in balanced tree h = O(log n).

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
static void inorder(struct TreeNode* root, int *k, int *ans) {
    if (!root || *k == 0) return;

    inorder(root->left, k, ans);

    if (--(*k) == 0) {           // visit this node
        *ans = root->val;
        return;                  // found it; early exit
    }

    inorder(root->right, k, ans);
}


int kthSmallest(struct TreeNode* root, int k) {
    int ans = -1;
    inorder(root, &k, &ans);
    return ans;
}
```

![Shiny kingdra](https://projectpokemon.org/images/shiny-sprite/kingdra.gif)
