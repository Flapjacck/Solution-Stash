# [704. Binary Search](https://leetcode.com/problems/binary-search/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1873660797/)

## Notes

This solution implements the classic binary search algorithm to find a target value in a sorted array:

1. **Two pointers**: Initialize `start` at the beginning and `end` at the last index
2. **Midpoint calculation**: Find the middle index to divide the search space
3. **Comparison and elimination**:
   - If middle element equals target, return the index
   - If target is greater, search the right half (start = mid + 1)
   - If target is smaller, search the left half (end = mid - 1)
4. **Loop termination**: Continue until `start > end`, meaning target not found

The key insight is dividing the search space in half with each iteration, eliminating half of the remaining elements.

### Time Complexity: O(log n)

- Each iteration eliminates half of the remaining elements
- For an array of size n, we need at most logâ‚‚(n) iterations
- Each iteration performs constant time operations (comparison and arithmetic)
- Overall: O(log n) where n is the size of the array

### Space Complexity: O(1)

- Only uses a constant amount of extra variables (`start`, `end`, `mid`)
- No additional data structures or recursion stack
- Space usage doesn't depend on input size

```c
int search(int* nums, int numsSize, int target) {
    int start = 0;
    int end = numsSize - 1;

    while (start <= end) {
        int mid = (start + end) / 2;
        if (nums[mid] == target) return mid;
        if (target > nums[mid]) start = mid + 1;
        else end = mid - 1;
    }
    return -1;
}
```

![Shiny goomy](https://projectpokemon.org/images/shiny-sprite/goomy.gif)
