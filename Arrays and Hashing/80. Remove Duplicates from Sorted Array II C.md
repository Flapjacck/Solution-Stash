# 80. Remove Duplicates from Sorted Array II

## [Solution Link](https://leetcode.com/submissions/detail/1815385539/)

## Notes

- If there are 2 or fewer elements, no duplicates need to be removed
- Use two pointers: `prev` tracks the last valid element, `curr` checks new elements
- Loop through the array starting from index 2
- If current element appears more than twice (equals both `prev` and `prev-1`), skip it
- Otherwise, keep the current element by incrementing `prev` and copying the value
- Return the new length (prev is index, so add 1 for count)

### Time Complexity: O(n)

Where n is the length of the input array:

- Single pass through the array with the `curr` pointer: O(n)
- Each comparison and assignment operation takes O(1)
- Overall complexity is O(n)

### Space Complexity: O(1)

The algorithm modifies the array in-place:

- Only uses two integer pointers (`prev` and `curr`): O(1)
- No additional data structures are created
- All operations are performed in-place

```c
int removeDuplicates(int* nums, int numsSize) {
    // If there are 2 or fewer elements, no duplicates need to be removed
    if (numsSize <= 2) return numsSize;
    // Index of the last valid (kept) element
    int prev = 1;
    // Index of the current element being checked
    int curr = 2;

    // Loop through the array starting from index 2
    while (curr < numsSize) {
        // If current element appears more than twice, skip it
        if (nums[curr] == nums[prev] && nums[curr] == nums[prev - 1]) curr++;
        // Otherwise, keep the current element
        else {
            prev++;
            nums[prev] = nums[curr];
            curr++;
        }
    }

    // Return the new length (prev is index, so add 1 for count)
    return prev + 1;
}
```

![Shiny slowbro](https://projectpokemon.org/images/shiny-sprite/slowbro.gif)
