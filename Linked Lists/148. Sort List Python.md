# [148. Sort List](https://leetcode.com/problems/sort-list/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1723678063/)

## Notes

This solution sorts a linked list using merge sort with a divide-and-conquer approach:

1. **Base case**: Return if list has 0 or 1 node (already sorted)
2. **Divide**: Split the list into two halves using the slow/fast pointer technique
3. **Conquer**: Recursively sort both halves
4. **Merge**: Combine the two sorted halves into one sorted list

Key components:

- `getMiddle()`: Finds the middle node and returns both the node before middle and the middle node
- `merge()`: Merges two sorted linked lists into one sorted list
- `mergeSort()`: Main recursive function that implements the divide-and-conquer strategy

The algorithm maintains O(n log n) time complexity while using only O(log n) extra space for recursion.

### Time Complexity: O(n log n)

Where n is the number of nodes in the linked list:

- Dividing the list takes O(log n) levels (splitting in half each time)
- At each level, merging all sublists takes O(n) time
- Overall: O(log n) Ã— O(n) = O(n log n)

### Space Complexity: O(log n)

Where n is the number of nodes in the linked list:

- Recursion stack depth: O(log n) due to divide-and-conquer approach
- No additional data structures are created (sorting in-place by rearranging pointers)
- Each recursive call uses O(1) extra space 

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next

class Solution:
    def sortList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        if not head or not head.next:
            return head
        
        # Helper function to find the middle of the list using slow and fast pointers
        def getMiddle(node):
            slow = node
            fast = node
            prev = None
            while fast and fast.next:
                prev = slow
                slow = slow.next
                fast = fast.next.next
            return prev, slow
        
        # Helper function to merge two sorted lists
        def merge(list1, list2):
            dummy = ListNode(0)
            current = dummy
            while list1 and list2:
                if list1.val <= list2.val:
                    current.next = list1
                    list1 = list1.next
                else:
                    current.next = list2
                    list2 = list2.next
                current = current.next
            current.next = list1 if list1 else list2
            return dummy.next
        
        # Bottom-up merge sort
        def mergeSort(node):
            if not node or not node.next:
                return node
            
            # Split list into two halves
            prev, mid = getMiddle(node)
            second_half = mid
            prev.next = None  # Disconnect first half
            
            # Recursively sort both halves
            left = mergeSort(node)
            right = mergeSort(second_half)
            
            # Merge the sorted halves
            return merge(left, right)
        
        return mergeSort(head)
```

![Shiny dragonair](https://projectpokemon.org/images/shiny-sprite/dragonair.gif)
