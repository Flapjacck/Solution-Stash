# [160. Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1729210109/)

## Notes

This solution finds the intersection of two linked lists using an elegant two-pointer approach:

1. Initialize two pointers (a and b) at the heads of both lists
2. Move both pointers forward simultaneously:
   - When pointer a reaches the end of list A, redirect it to head of list B
   - When pointer b reaches the end of list B, redirect it to head of list A
3. Continue until both pointers meet (intersection) or both become NULL (no intersection)

The key insight: After redirection, both pointers will have traveled the same total distance when they meet:

- If intersection exists: both travel (lenA + lenB - common_length)
- If no intersection: both travel (lenA + lenB) and meet at NULL

This eliminates the need to calculate list lengths separately.

### Time Complexity: O(m + n)

Where m and n are the lengths of the two linked lists:

- Each pointer traverses at most m + n nodes total
- In worst case (no intersection), each pointer visits every node in both lists once
- Overall complexity is O(m + n)

### Space Complexity: O(1)

The algorithm uses constant extra space:

- Only two pointer variables (a and b) are used: O(1)
- No additional data structures are created
- All operations are performed using the existing list structure

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) {
    struct ListNode *a = headA, *b = headB;
    while (a != b) {
        a = !a ? headB : a->next;
        b = !b ? headA : b->next;
    }
    return a;
}
```

![Shiny feraligatr](https://projectpokemon.org/images/shiny-sprite/feraligatr.gif)
