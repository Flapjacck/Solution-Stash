# [204. Count Primes](https://leetcode.com/problems/count-primes/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1738789931/)

## Notes

This solution counts prime numbers less than n using the Sieve of Eratosthenes algorithm:

1. Create a boolean array `is_prime` of size n, initially all set to true
2. Mark 0 and 1 as non-prime (false)
3. For each number i from 2 to √n:
   - If i is marked prime, mark all its multiples as non-prime
   - Start marking from i² since smaller multiples would have been marked by smaller primes
4. Count the remaining numbers marked as prime
5. Free allocated memory and return the count

Key optimizations:

- Only check numbers up to √n in the outer loop (sufficient to mark all non-primes)
- Start marking multiples from i² since smaller multiples are already marked
- Use a boolean array for efficient marking and counting

### Time Complexity: O(n log log n)

Where n is the input number:

- Creating and initializing the array takes O(n) time
- The outer loop runs from 2 to √n: O(√n)
- For each prime p in the outer loop, the inner loop marks approximately n/p multiples
- The total number of operations is O(n log log n) when summing n/p across all primes p
- The final counting takes O(n)
- Overall complexity is O(n log log n)

### Space Complexity: O(n)

The space complexity is determined by the boolean array:

- The `is_prime` array requires O(n) space to mark all numbers from 0 to n-1
- A few additional variables use O(1) space
- Overall space complexity is O(n)

```c
int countPrimes(int n) {
    // Handle edge cases: no primes less than 2
    if (n <= 2) {
        return 0;
    }
    
    // Allocate boolean array to mark numbers as prime (true) or not (false)
    bool* is_prime = (bool*)malloc(n * sizeof(bool));
    // Initialize all numbers as prime (true)
    for (int i = 0; i < n; i++) {
        is_prime[i] = true;
    }
    // Mark 0 and 1 as non-prime
    is_prime[0] = is_prime[1] = false;
    
    // Use Sieve of Eratosthenes to mark non-prime numbers
    for (int i = 2; i * i < n; i++) {
        if (is_prime[i]) {
            // Mark multiples of i starting from i*i as non-prime
            for (int j = i * i; j < n; j += i) {
                is_prime[j] = false;
            }
        }
    }
    
    // Count the number of primes
    int prime_count = 0;
    for (int i = 2; i < n; i++) {
        if (is_prime[i]) {
            prime_count++;
        }
    }
    
    // Free allocated memory
    free(is_prime);
    return prime_count;
}
```

![Shiny pineco](https://projectpokemon.org/images/shiny-sprite/pineco.gif)
