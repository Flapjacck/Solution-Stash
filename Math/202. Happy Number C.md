# [202. Happy Number](https://leetcode.com/problems/happy-number/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1737681259/)

## Notes

This solution determines if a number is "happy" using recursion and mathematical properties:

1. A happy number is one where the sum of squares of its digits eventually leads to 1
2. The solution uses these key optimizations:
   - Base cases for quick returns: 1 and 7 are the only single-digit happy numbers
   - Any single-digit number other than 1 or 7 can never be happy
   - For multi-digit numbers, calculate sum of squares of digits and recurse
3. The recursion continues until either:
   - We reach 1 (happy number) or 7 (which eventually leads to 1)
   - We reach a single-digit number that isn't 1 or 7 (not happy)

Mathematical insight: All numbers either:

- Eventually reach 1 (happy numbers)
- Enter a cycle that doesn't include 1 (unhappy numbers)
- For single-digit numbers, only 1 and 7 lead to 1

### Time Complexity: O(log n)

Where n is the input number:

- Computing the sum of squares of digits takes O(log n) time as a number n has log₁₀(n) digits
- The recursion depth depends on how many iterations before reaching a single digit
- This typically converges quickly, with O(log n) recursive calls
- Overall complexity is O(log n)

### Space Complexity: O(log n)

The space complexity is determined by the recursion stack:

- Each recursive call uses O(1) additional space
- Maximum recursion depth is O(log n) before converging
- No additional data structures are used
- Overall space complexity is O(log n) due to the recursion stack

```c
bool isHappy(int number) {
    // Base cases: 1 and 7 are known single-digit happy numbers
    if (number == 1 || number == 7) {
        return true;
    }
    // Base case: single-digit numbers other than 1 or 7 are not happy
    else if (number < 10) {
        return false;
    }
    // Compute sum of squares of digits and recurse
    else {
        int digit_square_sum = 0;
        while (number > 0) {
            int digit = number % 10; // Extract the last digit
            digit_square_sum += digit * digit; // Add square of digit to sum
            number /= 10; // Remove the last digit
        }
        return isHappy(digit_square_sum); // Recurse with the sum
    }
}
```

![Shiny wobbuffet](https://projectpokemon.org/images/shiny-sprite/wobbuffet.gif)
