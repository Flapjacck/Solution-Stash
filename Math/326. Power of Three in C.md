# [326. Power of Three](https://leetcode.com/problems/power-of-three/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1777336848/)

## Notes

This solution determines if a number is a power of three using a recursive approach:

1. **Base cases**:
   - If n = 1, return true (3⁰ = 1 is a power of three)
   - If n ≤ 0, return false (negative numbers and zero can't be powers of three)
   - If n is not divisible by 3, return false (not a power of three)
2. **Recursive case**:
   - Divide n by 3 and check if the result is a power of three
   - This effectively reduces the problem: if n = 3ᵏ, then n/3 = 3ᵏ⁻¹

The solution elegantly checks if n can be repeatedly divided by 3 until reaching 1, without any remainder along the way.

### Time Complexity: O(log₃ n)

Where n is the input number:

- Each recursive call divides n by 3
- The number of recursive calls equals the number of times we can divide n by 3
- For a power of three n = 3ᵏ, this takes k steps, where k = log₃(n)
- Overall complexity is O(log₃ n) or O(log n)

### Space Complexity: O(log₃ n)

The space complexity is determined by the recursion stack:

- Each recursive call uses O(1) additional space
- Maximum recursion depth is log₃(n) for valid powers of three
- Overall space complexity is O(log₃ n) or O(log n)

```c
bool isPowerOfThree(int n) {
    if (n == 1) return true;
    if (n <= 0 || n % 3 != 0) return false;
    return isPowerOfThree(n / 3);
}
```

![Shiny pineco](https://projectpokemon.org/images/shiny-sprite/grumpig.gif)
