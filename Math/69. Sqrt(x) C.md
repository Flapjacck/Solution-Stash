# [69. Sqrt(x)](https://leetcode.com/problems/sqrtx/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1735424311/)

## Notes

This solution finds the integer square root of x using a linear search approach:

1. Start with a candidate root of 1 and increment it until its square exceeds x
2. Use `unsigned long long` type for the square calculation to handle large inputs
3. Once the square exceeds x, decrement the root once to get the correct answer
4. Return the result (largest integer r such that r² ≤ x)

Key considerations:

- Using `unsigned long long` prevents integer overflow when calculating squares
- The loop continues until finding the first root where root² > x
- The decrement after finding such a root ensures we return the correct value

### Time Complexity: O(√n)

Where n is the input integer x:

- We increment the root value starting from 1 until reaching √x
- The number of iterations is proportional to √x
- Each iteration performs constant time operations
- Overall complexity is O(√n)

### Space Complexity: O(1)

The algorithm uses constant extra space:

- Only uses two variables (root and square): O(1)
- No additional data structures are created
- Space usage is independent of input size

```c
int mySqrt(int x) {
    // Initialize variables: root for square root, square for its square
    unsigned long long square;
    int root = 1;
    
    // Iterate until the square exceeds x
    while (root) {
        square = (unsigned long long)root * root; // Calculate square of current root
        if (square > x) {
            root--; // Decrease root if square exceeds input
            break;
        }
        root++; // Increment root to try next value
    }
    return root; // Return the largest integer whose square is <= x
}
```

![Shiny bellsprout](https://projectpokemon.org/images/shiny-sprite/bellsprout.gif)
