# [7. Reverse Integer](https://leetcode.com/problems/reverse-integer/description/)

## [Solution Link](https://leetcode.com/submissions/detail/1776496731/)

## Notes

This solution reverses an integer by extracting digits one by one and building the reversed number:

1. **Digit extraction**: Use modulo operation to get the last digit of the number
2. **Number building**: Multiply current sum by 10 and add the extracted digit
3. **Integer division**: Remove the last digit from the original number
4. **Overflow protection**: Use `long` to detect if result exceeds 32-bit integer limits

The key insight is using `long` data type to safely check for overflow before returning the result as an `int`.

### Time Complexity: O(log n)

- The while loop runs for each digit in the number
- Number of digits in an integer n is log₁₀(n)
- Each iteration performs constant time operations
- Overall: O(log n) where n is the input integer

### Space Complexity: O(1)

- Only uses a constant amount of extra variables (`sum`, `rem`)
- No additional data structures or recursion
- Space usage doesn't depend on input size

```c
int reverse(int x){
    long sum = 0;

    while(x != 0) {
        int rem = x % 10;
        sum = sum * 10 + rem;
        x = x / 10;
    }

    if (sum > INT_MAX || sum < INT_MIN){
        return 0;
    }
    return (int)sum;

}
```

![Shiny squirtle](https://projectpokemon.org/images/shiny-sprite/squirtle.gif)
